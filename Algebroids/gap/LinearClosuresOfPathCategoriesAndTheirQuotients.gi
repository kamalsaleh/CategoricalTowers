# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

BindGlobal( "LINEAR_CLOSURE_OF_PATH_CATEGORIES_OR_THEIR_QUOTIENTS",
  
  function ( k, C )
    local admissible_order, colors, sorting_func, kC;
    
    admissible_order := ValueOption( "admissible_order" );
    
    if admissible_order = fail then
        
        if IsPathCategory( C ) then
          admissible_order := C!.admissible_order;
        else
          admissible_order := UnderlyingCategory( C )!.admissible_order;
        fi;
        
    elif not admissible_order in [ "Dp", "dp" ] then
        
        Error( "only \"Dp\" and \"dp\" admissible orders are supported!\n" );
        
    fi;
    
    colors := ValueOption( "colors" );
    
    if colors = fail then
        
        colors := rec( coeff := "", other := "", reset := "" );
        
    elif colors = true then
        
        colors := rec( coeff := TextAttr.5, other := TextAttr.1, reset := TextAttr.reset );
        
    fi;
    
    if IsPathCategory( C ) then
        
        sorting_func := { mor_1, mor_2 } -> IsDescendingForMorphisms( C, mor_1, mor_2, admissible_order );
        
    else
        
        sorting_func := { mor_1, mor_2 } -> IsDescendingForMorphisms( UnderlyingCategory( C ), CanonicalRepresentative( mor_1 ), CanonicalRepresentative( mor_2 ), admissible_order );
        
    fi;
    
    kC := LinearClosure( k, C, sorting_func : FinalizeCategory := false ); # every morphism starts by its maximum monomial
    
    SetIsObjectFiniteCategory( kC, true );
    
    kC!.Name := Concatenation( RingName( k ), "-", kC!.Name );
    
    kC!.admissible_order := admissible_order;
    
    kC!.colors := colors;
    
    SetUnderlyingQuiver( kC, UnderlyingQuiver( C ) );
    
    AddSetOfObjectsOfCategory( kC,
      function( kC )
        local C;
        
        C := UnderlyingCategory( kC );
        
        return List( SetOfObjects( C ), o -> ObjectConstructor( kC, o ) );
        
    end );
    
    AddSetOfGeneratingMorphismsOfCategory( kC,
      function( kC )
        local C;
        
        C := UnderlyingCategory( kC );
        
        return List( SetOfGeneratingMorphisms( C ), m ->
                     MorphismConstructor( kC,
                             SetOfObjects( kC )[ObjectIndex( Source( m ) )],
                             Pair( [ One( UnderlyingRing( kC ) ) ], [ m ] ),
                             SetOfObjects( kC )[ObjectIndex( Target( m ) )] ) );
        
    end );
    
    SetDefiningTripleOfUnderlyingQuiver( kC, DefiningTripleOfUnderlyingQuiver( C ) );
    ## this is a hotfix: delete as soon as we install all derivations at once in Finalize instead of the step-by-step addition of derivations in the Add-functions.
    Reevaluate( kC!.derivations_weight_list );
    
    if CanCompute( C, "MorphismsOfExternalHom" ) then
        
        SetIsLinearCategoryOverCommutativeRingWithFinitelyGeneratedFreeExternalHoms( kC, true );
        
        ##
        AddBasisOfExternalHom( kC,
          
          function ( kC, source, target )
            local k, C;
            
            k := UnderlyingRing( kC );
            C := UnderlyingCategory( kC );
            
            return List( MorphismsOfExternalHom( C, ObjectDatum( kC, source ), ObjectDatum( kC, target ) ),
                            m -> MorphismConstructor( kC, source, Pair( [ One( k ) ], [ m ] ), target ) );
            
        end );
        
        ##
        AddCoefficientsOfMorphism( kC,
          
          function ( kC, alpha )
            local k, C, supp, coef, external_hom, indices;
            
            k := UnderlyingRing( kC );
            C := UnderlyingCategory( kC );
            
            supp := SupportMorphisms( alpha );
            coef := CoefficientsList( alpha );
            
            external_hom := MorphismsOfExternalHom( C, ObjectDatum( kC, Source( alpha ) ), ObjectDatum( kC, Target( alpha ) ) );
            
            indices := List( supp, mor -> PositionProperty( external_hom, m -> IsCongruentForMorphisms( C, m, mor ) ) );
            
            return List( [ 1 .. Length( external_hom ) ],
                    function ( i )
                      local p;
                      
                      p := Position( indices, i );
                      
                      if p <> fail then
                          return coef[p];
                      else
                          return Zero( k );
                      fi;
                      
                    end );
            
        end );
         
    fi;
    
    INSTALL_VIEW_AND_DISPLAY_METHODS_IN_LINEAR_CLOSURES_OF_PATH_CATEGORIES_OR_THEIR_QUOTIENTS( kC );
    
    Append( kC!.compiler_hints.category_attribute_names,
            [ "UnderlyingQuiver",
              "DefiningTripleOfUnderlyingQuiver",
              ] );
    
    Finalize( kC );
    
    return kC;
    
end );

##
InstallOtherMethod( LinearClosure,
          [ IsHomalgRing, IsPathCategory ],
  
  LINEAR_CLOSURE_OF_PATH_CATEGORIES_OR_THEIR_QUOTIENTS
);

##
InstallOtherMethod( \[\],
          [ IsHomalgRing, IsPathCategory ],
  
  function ( k, C )
    
    return LinearClosure( k, C );
    
end );

##
InstallOtherMethod( LinearClosure,
          [ IsHomalgRing, IsQuotientOfPathCategory ],
  
  LINEAR_CLOSURE_OF_PATH_CATEGORIES_OR_THEIR_QUOTIENTS
);

##
InstallOtherMethod( \[\],
          [ IsHomalgRing, IsQuotientOfPathCategory ],
  
  function ( k, C )
    
    return LinearClosure( k, C );
    
end );

##
InstallMethod( TensorProductOfLinearClosures,
            "tensor product of linear closures of path categories",
            [ IsLinearClosure, IsLinearClosure ],
  
  function ( kP1, kP2 )
    local P1, P2, ring, q1, quiver_datum_1, q2, quiver_datum_2, q1xq2, P, kP, gmors_kP, rels;
    
    P1 := UnderlyingCategory( kP1 );
    P2 := UnderlyingCategory( kP2 );
    
    if not (IsPathCategory( P1 ) and IsPathCategory( P2 )) then
          TryNextMethod( );
    fi;
    
    ring := UnderlyingRing( kP1 );
    
    if not IsIdenticalObj( ring, UnderlyingRing( kP2 ) ) then
        Error( "the passed linear closures must have the same underlying ring!\n" );
    fi;
    
    q1 := UnderlyingQuiver( P1 );
    quiver_datum_1 := QuiverDatum( q1 );
    
    q2 := UnderlyingQuiver( P2 );
    quiver_datum_2 := QuiverDatum( q2 );
    
    q1xq2 := TensorProductOfFinQuivers( q1, q2 );
    
    P := PathCategory( q1xq2 );
    
    kP := LinearClosure( ring, P );
    
    gmors_kP := SetOfGeneratingMorphisms( kP );
    
    rels :=
      Concatenation(
        List( [ 1 .. quiver_datum_1[3][1] ], i ->
          List( [ 1 .. quiver_datum_2[3][1] ], j ->
            SubtractionForMorphisms( kP,
              PreCompose( kP,
                gmors_kP[(quiver_datum_1[3][2][i] - 1) * quiver_datum_2[3][1] + j],
                gmors_kP[quiver_datum_1[2][1] * quiver_datum_2[3][1] + (i-1) * quiver_datum_2[2][1] + quiver_datum_2[3][3][j]] ),
              PreCompose( kP,
                gmors_kP[quiver_datum_1[2][1] * quiver_datum_2[3][1] + (i-1) * quiver_datum_2[2][1] + quiver_datum_2[3][2][j]],
                gmors_kP[(quiver_datum_1[3][3][i] - 1) * quiver_datum_2[3][1] + j] ) ) ) ) );
    
    return QuotientCategory( kP, rels );
    
end );

##
InstallMethod( TensorProductOfLinearClosures,
            "tensor product of linear closures of quotients of path categories",
            [ IsLinearClosure, IsLinearClosure ],
  
  function ( kC1, kC2 )
    local C1, C2, ring, P1, P2, kP1, kP2, groebner_basis_1, groebner_basis_2, kP1_x_kP2, rels_0, rels_1, rels_2;
    
    C1 := UnderlyingCategory( kC1 );
    C2 := UnderlyingCategory( kC2 );
    
    if not (IsQuotientOfPathCategory( C1 ) and IsQuotientOfPathCategory( C2 )) then
          TryNextMethod( );
    fi;
    
    ring := UnderlyingRing( kC1 );
    
    if not IsIdenticalObj( ring, UnderlyingRing( kC2 ) ) then
        Error( "the passed linear closures must have the same underlying ring!\n" );
    fi;
    
    P1 := UnderlyingCategory( C1 );
    P2 := UnderlyingCategory( C2 );
    
    kP1 := LinearClosure( ring, P1 );
    kP2 := LinearClosure( ring, P2 );
    
    groebner_basis_1 :=
      List( GroebnerBasisOfDefiningRelations( C1 ),
        r -> MorphismConstructor( kP1,
                SetOfObjects( kP1 )[ObjectIndex( Source( r[1] ) )],
                Pair( [ One( ring ), -One( ring ) ], r ),
                SetOfObjects( kP1 )[ObjectIndex( Target( r[1] ) )] ) );
    
    groebner_basis_2 :=
      List( GroebnerBasisOfDefiningRelations( C2 ),
        r -> MorphismConstructor( kP2,
                SetOfObjects( kP2 )[ObjectIndex( Source( r[1] ) )],
                Pair( [ One( ring ), -One( ring ) ], r ),
                SetOfObjects( kP2 )[ObjectIndex( Target( r[1] ) )] ) );
    
    kP1_x_kP2 := TensorProductOfLinearClosures( kP1, kP2 );
    
    rels_0 := GroebnerBasisOfDefiningRelations( kP1_x_kP2 );
    
    rels_1 :=
      Concatenation(
        List( SetOfObjects( kP1 ), o ->
          List( groebner_basis_2, r ->
            UnderlyingCell( ElementaryTensor( o, r, kP1_x_kP2 ) ) ) ) );

    rels_2 :=
      Concatenation(
        List( groebner_basis_1, r ->
          List( SetOfObjects( kP2 ), o ->
            UnderlyingCell( ElementaryTensor( r, o, kP1_x_kP2 ) ) ) ) );
    
    return QuotientCategory( UnderlyingCategory( kP1_x_kP2 ),  Concatenation( rels_0, rels_1, rels_2 ) );
    
end );

##
InstallOtherMethod( ElementaryTensor,
          [ IsLinearClosureObject, IsLinearClosureObject, IsQuotientCapCategory ],
  
  function ( obj_1, obj_2, kC1_x_kC2 )
    local q2;
    
    q2 := UnderlyingQuiver( CapCategory( obj_2 ) );
    
    return SetOfObjects( kC1_x_kC2 )[( ObjectIndex( ObjectDatum( obj_1 ) ) - 1 ) * NumberOfObjects( q2 ) + ObjectIndex( ObjectDatum( obj_2 ) )];
    
end );

##
InstallOtherMethod( ElementaryTensor,
          [ IsLinearClosureObject, IsLinearClosureMorphism, IsQuotientCapCategory ],
  
  function ( obj, mor, kC1_x_kC2 )
    local q2, obj_index, coeffs, supprt, supprt_indices, source, target;
    
    if not IsPathCategory( UnderlyingCategory( UnderlyingCategory( kC1_x_kC2 ) ) ) then
            TryNextMethod( );
    fi;
    
    q2 := UnderlyingQuiver( CapCategory( mor ) );
    
    obj_index := ObjectIndex( ObjectDatum( obj ) );
    
    coeffs := CoefficientsList( mor );
    supprt := SupportMorphisms( mor );
    
    if IsPathCategory( UnderlyingCategory( CapCategory( mor ) ) ) then
        supprt_indices := List( supprt, m -> MorphismIndices( m ) );
    else
        supprt_indices := List( supprt, m -> MorphismIndices( UnderlyingCell( m ) ) );
    fi;
    
    supprt_indices :=
      List( supprt_indices, m_indices ->
        List( m_indices, index ->
          (obj_index - 1) * NumberOfMorphisms( q2 ) + index ) );
    
    source := ElementaryTensor( obj, Source( mor ), kC1_x_kC2 );
    target := ElementaryTensor( obj, Target( mor ), kC1_x_kC2 );
    
    supprt :=
      List( supprt_indices, indices ->
        MorphismConstructor( UnderlyingCategory( UnderlyingCategory( kC1_x_kC2 ) ),
          ObjectDatum( ObjectDatum( source ) ),
          Pair( Length( indices ), indices ),
          ObjectDatum( ObjectDatum( target ) ) ) );
    
    return MorphismConstructor( kC1_x_kC2,
              source,
              MorphismConstructor( UnderlyingCategory( kC1_x_kC2 ),
                  UnderlyingCell( source ),
                  Pair( coeffs, supprt ),
                  UnderlyingCell( target )  ),
              target );
    
end );

##
InstallOtherMethod( ElementaryTensor,
          [ IsLinearClosureMorphism, IsLinearClosureObject, IsQuotientCapCategory ],
  
  function ( mor, obj, kC1_x_kC2 )
    local q1, q2, obj_index, coeffs, supprt, supprt_indices, source, target;
    
    if not IsPathCategory( UnderlyingCategory( UnderlyingCategory( kC1_x_kC2 ) ) ) then
            TryNextMethod( );
    fi;
    
    q1 := UnderlyingQuiver( CapCategory( mor ) );
    q2 := UnderlyingQuiver( CapCategory( obj ) );
    
    obj_index := ObjectIndex( ObjectDatum( obj ) );
    
    coeffs := CoefficientsList( mor );
    supprt := SupportMorphisms( mor );
    
    if IsPathCategory( UnderlyingCategory( CapCategory( mor ) ) ) then
        supprt_indices := List( supprt, m -> MorphismIndices( m ) );
    else
        supprt_indices := List( supprt, m -> MorphismIndices( UnderlyingCell( m ) ) );
    fi;
    
    supprt_indices :=
      List( supprt_indices, m_indices ->
        List( m_indices, index ->
          NumberOfObjects( q1 ) * NumberOfMorphisms( q2 ) + (index - 1) * NumberOfObjects( q2 ) + obj_index ) );
    
    source := ElementaryTensor( Source( mor ), obj, kC1_x_kC2 );
    target := ElementaryTensor( Target( mor ), obj, kC1_x_kC2 );
    
    supprt :=
      List( supprt_indices, indices ->
        MorphismConstructor( UnderlyingCategory( UnderlyingCategory( kC1_x_kC2 ) ),
          ObjectDatum( ObjectDatum( source ) ),
          Pair( Length( indices ), indices ),
          ObjectDatum( ObjectDatum( target ) ) ) );
    
    
    return MorphismConstructor( kC1_x_kC2,
              source,
              MorphismConstructor( UnderlyingCategory( kC1_x_kC2 ),
                  UnderlyingCell( source ),
                  Pair( coeffs, supprt ),
                  UnderlyingCell( target )  ),
              target );
    
    
end );

##
InstallOtherMethod( ElementaryTensor,
          [ IsLinearClosureMorphism, IsLinearClosureMorphism, IsQuotientCapCategory ],
  
  function ( mor_1, mor_2, kC1_x_kC2 )
    
    return PreCompose( kC1_x_kC2,
          ElementaryTensor( mor_1, Source( mor_2 ), kC1_x_kC2 ),
          ElementaryTensor( Target( mor_1 ), mor_2, kC1_x_kC2 ) );
    
end );

##
InstallMethodForCompilerForCAP( SetOfObjects,
        "for a linear closure category",
        [ IsLinearClosure ],
        
  function( cat )
    
    return SetOfObjectsOfCategory( cat );
    
end );

##
InstallMethodForCompilerForCAP( SetOfGeneratingMorphisms,
        "for a linear closure category",
        [ IsLinearClosure ],
        
  function( cat )
    
    return SetOfGeneratingMorphismsOfCategory( cat );
    
end );

##
InstallGlobalFunction( "INSTALL_VIEW_AND_DISPLAY_METHODS_IN_LINEAR_CLOSURES_OF_PATH_CATEGORIES_OR_THEIR_QUOTIENTS",
  
  function ( kC )
    local C;
     
    C := UnderlyingCategory( kC );
    
    if IsQuotientOfPathCategory( C ) then
        
        C := UnderlyingCategory( C );
        
    fi;
    
    ##
    InstallMethod( ViewString,
              [ ObjectFilter( kC ) ],
      
      function ( obj )
        
        return ViewString( ObjectDatum( obj ) );
        
    end );
    
    ##
    InstallMethod( DisplayString,
              [ ObjectFilter( kC ) ],
      
      obj -> Concatenation( ViewString( obj ), "\n" )
    );
    
    ##
    InstallMethod( ViewString,
              [ MorphismFilter( kC ) ],
      
      function ( alpha )
        local kC, Q, coeffs, labels, datum_string;
        
        kC := CapCategory( alpha );
        
        Q := UnderlyingQuiver( C );
        
        coeffs := List( CoefficientsList( alpha ), c -> Concatenation( kC!.colors.coeff, String( c ), kC!.colors.reset ) );
        
        labels := List( SupportMorphisms( alpha ), m -> ( str -> str{[1 .. PositionSublist( str, Concatenation( Q!.colors.other, ":" ) ) - 1]} )( ViewString( m ) ) );
        
        if IsEmpty( labels ) then
            
            datum_string := Concatenation( kC!.colors.coeff, "0", kC!.colors.reset );
            
        else
            
            datum_string := JoinStringsWithSeparator( ListN( coeffs, labels, { c, l } -> Concatenation( c, "*", l ) ), Concatenation( kC!.colors.reset, " + " ) );
            datum_string := ReplacedString( datum_string, Concatenation( "+ ", kC!.colors.coeff, "-" ), Concatenation( "- ", kC!.colors.coeff ) );
        fi;
        
        return
          Concatenation(
              datum_string,
              Q!.colors.other,
              ":",
              ViewString( UnderlyingOriginalObject( Source( alpha ) ) ),
              Q!.colors.other,
              " -≻ ",
              ViewString( UnderlyingOriginalObject( Target( alpha ) ) ) );
          
    end );
    
    ##
    InstallMethod( DisplayString,
              [ MorphismFilter( kC ) ],
      
      mor -> Concatenation( ViewString( mor ), "\n" )
    );
    
end );

##
InstallMethod( \.,
          [ IsLinearClosure, IsPosInt ],
  
  function ( kC, string_as_int )
    local name, cell;
    
    name := NameRNam( string_as_int );
    
    cell := UnderlyingCategory( kC ).( name );
    
    if IsCapCategoryObject( cell ) then
        
        return ObjectConstructor( kC, cell );
        
    else
        
        return MorphismConstructor( kC,
                    ObjectConstructor( kC, Source( cell ) ),
                    Pair( [ One( UnderlyingRing( kC ) ) ], [ cell ] ),
                    ObjectConstructor( kC, Target( cell ) ) );
        
    fi;
    
end );

##
InstallMethod( DataTablesOfCategory,
            "for hom-finite k-linear closures of path categories",
          [ IsLinearClosure ],
  
  function ( kC )
    local C, q, objs, gmors, external_homs;
    
    if not HasRangeCategoryOfHomomorphismStructure( kC ) then
        Error( "the linear closure category passed to 'DataTablesOfCategory' must be hom-finite!" );
    fi;
    
    C := UnderlyingCategory( kC );
    
    if not (IsPathCategory( C ) or IsQuotientOfPathCategory( C ))  then
        
        TryNextMethod( );
        
    fi;
    
    q := UnderlyingQuiver( C );
    
    objs := SetOfObjects( kC );
    gmors := SetOfGeneratingMorphisms( kC );
    
    external_homs :=  List( objs, s -> List( objs, t -> BasisOfExternalHom( kC, s, t ) ) );
    
    return
      NTuple( 5,
      
      #coefficients_ring,
      UnderlyingRing( kC ),
      
      #quiver
      q,
      
      #decomposition_indices_of_bases_elements
      List( external_homs,
        s -> List( s, hom_st -> List( hom_st, m -> MorphismIndices( CanonicalRepresentative( SupportMorphisms( m )[1] ) ) ) ) ),
      
      # hom_structure_objs_gmors
      List( objs,
        o -> List( gmors,
          gm -> EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( HomomorphismStructureOnMorphisms( kC, IdentityMorphism( kC, o ), gm ) ) ) ) ),
      
      #hom_structure_gmors_objs
      List( objs,
        o -> List( gmors,
          gm -> EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( HomomorphismStructureOnMorphisms( kC, gm, IdentityMorphism( kC, o ) ) ) ) ) ) );
    
end );

##
InstallMethod( DatumOfCellAsEvaluatableString,
        [ IsLinearClosureMorphism, IsList ],
        
  function( mor, list_of_evaluatable_strings )
    local datum;
    
    datum := MorphismDatum( mor );
    
    return Concatenation(
                   "Pair( ", String( datum[1] ),
                   ", [ ",
                   JoinStringsWithSeparator( List( datum[2], e -> CellAsEvaluatableString( e, list_of_evaluatable_strings ) ), ", " ),
                   " ] )" );
    
end );
